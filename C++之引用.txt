注：我们使用术语“引用”时指的其实也就是“左值引用”。在后面我会为大家讲解什么是右值引用。   

     引用是为对象另起一个名字，引用类型引用另一种类型。
     编译器不会为引用变量开辟新空间，它与它所引用的变量共用一块空间。

     引用的初始化：
             类型 & 变量名=所引用的变量名；
     ①  int i=10;
     int &m=i;      //将m指向i，m是变量i的别名
     ② int &i；         //错误！！！引用变量必须初始化

     引用使用注意事项：

	1. 引用在定义时必须初始化
	2. 允许一个变量有多个引用
	3. 引用一旦绑定了实体，则不能改变为其他变量的引用


     const的引用：
     可以把引用对象绑定到const对象上，就行绑定到其他对象上一样，我们称之为对常量的引用。与普通引用不同的是，对常量的引用不能被用作修改它所指定的对象。
     const int i=10;
     const int & m=i;          //引用及其对应的对象都是常量

     除了两种特殊情况之外，其他所有引用的类型都要与之绑定的对象严格匹配。第一种例外就是在初始化常量引用时允许用任意表达式作为初始值，只要该表达式的结果能转换成引用的类型即可。另一种例外就是我们可以将基类的指针或者引用绑定到派生类对象上。
     int i=10;
     const int &m=i;      //允许将const int &绑定到一个普通的int类型上
     const int %n=20;     //n是一个常量引用
     const int &p=m*2;     //p是一个常量引用
     int &q=m*2;     //错误:q是一个普通的非常量引用
     这时，我们不禁要问为什么会出现允许将const int &绑定到一个普通的int类型上这种事情发生呢？接下来我们来看一下当一个常量绑定到另外一种类型上到底发生了什么：
     double i=3.14;
     const int &m=i;
     此时m引用了一个int类型的数。对于m进行的操作因该是整数运算，但是i却是一个双精度的浮点数而非整数。因此为了确保让m绑定一个整数，编译器其实偷偷做了如下操作：
     const int temp=i；        //由双精度浮点数生成了一个临时的整型常量
     const int &m=temp;      //让m绑定这个临时量
     临时量对象：当编译器需要一个空间来暂存表达式的求值结果时临时创建的一个未命名的对象，即临时量。
